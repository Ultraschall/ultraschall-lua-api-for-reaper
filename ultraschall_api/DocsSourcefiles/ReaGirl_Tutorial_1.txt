## First steps into ReaGirl

In ReaGirl, you basically have to work through 5 steps.

0. Initialize ReaGirl
1. Add some run-functions
2. Start a new gui using reagirl.Gui\_New()
3. Add some ui-elements using the various \_Add-functions
4. Open a gui using reagirl.Gui\_Open()
5. Write and run a defer-function, in which you call reagirl.Gui\_Manage()

Let's get into these steps in more details.

### Step 0: Initialize ReaGirl
First add the line

```
dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")
```
to your script. It will load all functions and features of ReaGirl. After that, you can start writing your guis with it.

### Step 1: Add some run-functions
Run-Functions are functions that are run, when the user interacts with a user-interface-element(ui-element). For instance, clicking a checkbox or a button.
Or typing/hitting enter into an inputbox. Or if the user moves the slider or selects a menu in a drop-down-menu.  
Or if the user selects a context-menu-entry or drag n drops files onto a ui-element.  
So in a run function you tell Reaper what to do, after the user interacted with a ui element.

A rule of thumb is: every ui-element and interaction-style gets it's own run-function.
So one for when the user hits the button. One for when the user types text into an inputbox and one for when the user hits enter into the inputbox, etc, etc.
These run-functions will get parameters passed from the gui, like the identifier of a ui-element(more on this later) or additional information like a selected menu-entry.
So run-functions are powerful and will make the magic happen, once the user interacted with a ui-element.

When writing a new gui, you can just write some "empty" functions that do nothing. We'll fill them in later.

### Step 2: Start a new gui using reagirl.Gui\_New()
This will tell ReaGirl, that you want to start a new gui. And it's simple, just add reagirl.Gui\_New() to your script and you're done.
You can also use this later in more complex scripts to throw away an already existing gui and start a new one, but in most cases, you'll only do this once at the beginning of your gui-script.

### Step 3: Add some ui-elements using the various \_Add-functions
Now the magic starts, we add our first ui-elements. You do it using the various \_Add-functions like Button\_Add, InputBox\_Add, DropDownMenu\_Add, Slider\_Add, CheckBox\_Add, Label\_Add, Image\_Add, etc.
All these add-functions will ask you for the position of the ui-element, a caption(which is usually shown next to it), an accessibility-hint which helps blind users to navigate and understand your gui and a run-function.
Some may ask you for more things like width and height(Images) or initial values(Checkboxes, Sliders, DropDownMenu) or even additional run-functions(InputBox uses one run-function when the user types text and one for when the user hits enter in the inputbox).

All \_Add-functions return a string called element\_id. This element\_id is like a unique name for your ui-element.
You can use this to do additional things with the ui-element. For instance, you can make the edges of a button more round or more edgier using the reagirl-Button\_SetRadius()-function.
The function needs this element\_id to know, of which button you want to edit the edges and alter it accordingly.
If you remember what I told you about run-functions, then you'll know already that element\_ids also passed to a run-function by ReaGirl.
So you can use one run-function for all buttons. You just check, whether the element\_id passed to the run-function is the same as the element\_id of button1, button2 or button3.
So keep these element\_ids in variables or tables, as you can do really nice things with it(we'll dive deeper into element\_ids in the tutorials).

You can add up to several thousand ui-elements in your gui(though usually, you will do much less).

### Step 4: Open a gui using reagirl.Gui\_Open()
This will open the gui. You can pass to it the position, the dimensions, the window-title, an accessibility-hint which tells the user what to expect from your gui and so on.
It's pretty straightforward, so just follow the documentation for what the parameters shall be.

### Step 5: Write and run a defer-function, in which you call reagirl.Gui\_Manage()

This one's also very easy. Add the following lines at the end of your script:

```
function main()
  reagirl.Gui_Manage()
  reaper.defer(main)
end

main()
```

This will run the Gui\_Manage-function, which basically does all the management of the gui, like drawing, click-management, runnning the run-functions when the user interacts with a ui-element, scrolling and other cool stuff, so you don't have to do it yourself.
And that's it, 5 steps to make your own gui.

In the next chapters, I will take you through some basic tutorials on how making a gui works in practice.
And we'll start with a basic one.



##Tutorial #1 - a basic gui

In this tutorial, I will show you how to make a basic gui with some buttons, inputboxes and checkboxes. I will also explain to you the basic concepts in practice that you need to know to make guis with ReaGirl.
Stick with me, it's easier than you think.

Let's start with a basic gui, which will show one single button.
```
  -- Step 0: initialize ReaGirl
  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")

  -- Step 1: write the run-functions
  function Button_RunFunction(pressed_button_id)
    -- this function is run, when a button is pressed
    reaper.MB("Buton has been pressed", "Pressed", 0)
  end

  -- Step 2: create new gui
  reagirl.Gui_New()
  
  -- Step 3: add the ui-elements to the gui
  -- add an ok-button to the gui
  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog", Button_RunFunction)
  
  -- Step 4: open the new gui
  reagirl.Gui_Open("The dialog", "This is a demo dialog with some options.", 640, 250)

  -- Step 5: Write and run a defer-function, in which you call reagirl.Gui_Manage()
  function main()
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly
    reagirl.Gui_Manage()
    
    -- if the gui-window hasn't been closed, keep the script alive.
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
  end

  main()

```  
You see the 5 steps I mentioned in the first steps-chapter. This adds a button and the run-function Button\_RunFunction which is run when the user hits the button.
Also note the parameter meaningOfUI\_Element, which is set to "Apply changes and close dialog". This parameter tells blind users, what the ui-element is supposed to do and why, so if you add your own ui-elements, add a short and descriptive explanation into this parameter. Blind users will thank you for that.
And that's it, a simple gui with one button. Try it and experiment with it. Write a different text into the button. Set other numbers into the parameters of reagirl.Button\_Add to see what happens.
Don't worry about making mistakes. When you pass wrong parameters to ReaGirl-functions, they will tell you with an error message, what went wrong and where.

You'll also note in the code, that reagirl.Button_Add() returns a returnvalue that I put into the variable button\_ok\_id. We will use this later on.

Now that you fiddled around with it, how about adding a second button?
For this, we add a second Button\_Add-function for a Cancel-button. We'll also give it the same run-function like the first button. The returned element\_id of the cancel-button we put into the variable button_cancel_id.
It's looks like the following code.

```  
  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")
  
  function Button_RunFunction(pressed_button_id)
    -- this function is run, when a button is pressed
    if pressed_button_id==button_ok_id then
      reaper.MB("OK Button is pressed", "OK Button", 0)
    elseif pressed_button_id==button_cancel_id then
      reaper.MB("Cancel Button is pressed", "Cancel Button", 0)
    end
  end

  -- create new gui
  reagirl.Gui_New()
  -- add an ok-button and a cancel button to the gui
  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog", Button_RunFunction)
  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, "Cancel", "Discard changes and close dialog", Button_RunFunction)

  -- open the new gui
  reagirl.Gui_Open("The dialog", "This is a demo dialog with some options.", 640, 250)

  function main()
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly
    reagirl.Gui_Manage()
    
    -- if the gui-window hasn't been closed, keep the script alive.
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
  end

  main()
```
You'll also notice, that I altered the runfunction Button\_RunFunction. I mentioned in the first steps chapter, that the run-function gets passed over several parameters, with the first one being the element\_id of the button that got pressed.
In our example, the function Button\_RunFunction has a parameter pressed\_button\_id into which ReaGirl will tell you, which button that uses this run-function got pressed.
You remember, that both added buttons share the same run-function.
And that's the reason, why the variables button\_ok\_id and button\_cancel\_id come in handy, because you can use them now to check, if pressed_button_id==button_ok_id(the ok-button got pressed) or if pressed_button_id==button_cancel_id(the cancel button got pressed).
In this code, we will show a message-box that tells you, which one had been pressed.
This way, all buttons can share the same run-function, as you can compare the element\_ids of each button with the parameter pressed\_button\_id.

As a little excercise, add another button called "Help". Put its return-value into the variable button\_help\_id and add to the run-function a help-message shown, when the help button is pressed.
It'll help you internalising how the mechanics work and will help you further down the road with more complex guis.

Now that we have two buttons, we could add another ui-element. This time it's checkboxes.
You know the drill: CheckBox\_Add adds checkboxes into the next script. The CheckBox\_Add-functions return the element\_ids which will be put into the variables checkbox\_remember and checkbox\_mysetting.
We also add a run-function for it called Checkbox\_RunFunction, which will pop up a dialog when one of the checkboxes is checked. It'll tell you which one it will be with the help of the element_\ids, just like we did with the buttons.

```
  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")
  
  function Button_RunFunction(pressed_button_id)
    -- this function is run, when a button is pressed
    if pressed_button_id==button_ok_id then
      reaper.MB("OK Button is pressed", "OK Button", 0)
    elseif pressed_button_id==button_cancel_id then
      reaper.MB("Cancel Button is pressed", "Cancel Button", 0)
    end
  end

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)
    -- this function is run, when the checkstate of a checkbox is changed
    if checked_checkbox_id==checkbox_remember then
      reaper.MB("Checkbox \"Remember\" is "..tostring(checkstate), "Checkbox-State changed", 0)
    elseif checked_checkbox_id==checkbox_mysetting then
      reaper.MB("Checkbox \"my Setting\" is "..tostring(checkstate), "Checkbox-State changed", 0)
    end
  end

  -- create new gui
  reagirl.Gui_New()

  -- add two checkboxes to the gui
  checkbox_mysetting = reagirl.CheckBox_Add(30, 150, "My setting", "How shall my setting be set?", true, Checkbox_RunFunction)
  checkbox_remember = reagirl.CheckBox_Add(30, 170, "Remember chosen setting", "Shall this setting be used as future default?", true, Checkbox_RunFunction)

  -- add an ok-button and a cancel button to the gui
  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog", Button_RunFunction)
  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, "Cancel", "Discard changes and close dialog", Button_RunFunction)

  -- open the new gui
  reagirl.Gui_Open("The dialog", "This is a demo dialog with some options.", 640, 250)

  function main()
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly
    reagirl.Gui_Manage()
    
    -- if the gui-window hasn't been closed, keep the script alive.
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
  end

  main()
```

One thing that's different from before is, that the run-function for the checkboxes Checkbox\_RunFunction gets now two parameters, whereas the one for the buttons only got one.
The parameters are 1) the element_id of the clicked checkbox(like it was in the button's run-function) AND 2) a parameter for the checkstate.
So a run-function for checkboxes gets the element_id and the state of the checkbox after it was clicked. That way you know, how the checkbox-state currently is.
You can then use it to store settings in the background: when the checkbox is checked you store "true" and when the checkbox is unchecked you store "false".
The different parameters of the run-functions is also the reason, why you cannot use the same run-function for all types of ui-elements, as different ui-elements pass over different parameters to the run-function.
This could confuse your code. It's possible to code around this but I highly recommend to only use one run-function for all buttons and one for all checkboxes and one for all sliders, etc.

Although you can do one run-function for each ui-element, which is perfectly fine.

Back to our example.

We have now two checkboxes and two buttons. Let's add another type of ui-elements: InputBoxes. 
InputBoxes allow to type in text into your gui. They are added basically like all other ui-elements: InputBox\_Add and two run-functions.

Two run-functions?

Yes, InputBoxes allow to have two run-functions. One is called everytime the user enters a character into the inputbox while the other one is called when the user hits enter into the inputbox.
Let's add two inputboxes with the two run-functions(InputBox\_RunFunction\_Type for when the user types text, InputBox\_RunFunction\_Enter for enter when the user hits enter into the inputbox).

```
  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")
  
  function Button_RunFunction(pressed_button_id)
    -- this function is run, when a button is pressed
    if pressed_button_id==button_ok_id then
      reaper.MB("OK Button is pressed", "OK Button", 0)
    elseif pressed_button_id==button_cancel_id then
      reaper.MB("Cancel Button is pressed", "Cancel Button", 0)
    end
  end

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)
    -- this function is run, when the checkstate of a checkbox is changed
    if checked_checkbox_id==checkbox_remember then
      reaper.MB("Checkbox \"Remember\" is "..tostring(checkstate), "Checkbox-State changed", 0)
    elseif checked_checkbox_id==checkbox_mysetting then
      reaper.MB("Checkbox \"My Setting\" is "..tostring(checkstate), "Checkbox-State changed", 0)
    end
  end

  function InputBox_RunFunction_Type(inputbox_id, entered_text)
    -- this function is run, when the user types in text into an inputbox
    reaper.ClearConsole()
    if inputbox_id==inputbox_name_of_setting then
      reaper.ShowConsoleMsg("NAME: "..entered_text)
    elseif inputbox_id==inputbox_description_of_setting then
      reaper.ShowConsoleMsg("DESCRIPTION: "..entered_text)
    end
  end

  function InputBox_RunFunction_Enter(inputbox_id, entered_text)
    -- this function is run, when the user hits enter into an inputbox
    if inputbox_id==inputbox_name_of_setting then
      reaper.MB(entered_text, "The typed text into NAME was", 0)
    elseif inputbox_id==inputbox_description_of_setting then
      reaper.MB(entered_text, "The typed text into DESCRIPTION was", 0)
    end
  end

  -- create new gui
  reagirl.Gui_New()

  -- add inputboxes to type in text
  inputbox_name_of_setting = reagirl.InputBox_Add(30, 105, 300, "Name of the setting:", 150, "Type in here the name of the setting", "No title", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)
  inputbox_description_of_setting = reagirl.InputBox_Add(30, 130, 300, "Description of the setting:", 150, "Type in here a description of the setting", "No Description", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)

  -- add two checkboxes to the gui
  checkbox_mysetting = reagirl.CheckBox_Add(30, 150, "My setting", "How shall my setting be set?", true, Checkbox_RunFunction)
  checkbox_remember = reagirl.CheckBox_Add(30, 170, "Remember chosen setting", "Shall this setting be used as future default?", true, Checkbox_RunFunction)

  -- add an ok-button and a cancel button to the gui
  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog", Button_RunFunction)
  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, "Cancel", "Discard changes and close dialog", Button_RunFunction)

  -- open the new gui
  reagirl.Gui_Open("The dialog", "This is a demo dialog with some options.", 640, 250)

  function main()
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly
    reagirl.Gui_Manage()
    
    -- if the gui-window hasn't been closed, keep the script alive.
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
  end

  main()
```
If you run this script, you can click into the inputbox and enter text. The entered text will be shown in the debugging-window "ReaScript Console" of Reaper.
This outputting is done by the run-function InputBox\_RunFunction\_Type. When you hit enter, a message-box appears which shows you the entered text. This is done by the run-function InputBox_RunFunction_Enter.
Both run-functions get as parameters the element\_id(inputbox\_id) as well as the entered text(entered\_text).

Ok, now we have two buttons, two checkboxes and two inputboxes, all doing stuff when clicking/typing.

I would like to introduce you to another ui-element, the label element. This allows you to show some text.
It's working the same: Label\_Add adds a label. This could potentially be made clickable which would mean, we need a run-function as well, but we just make it a regular label that ust shows text.
Therefore the last parameter for the run-function is nil(which means, no run-function available for this ui-element).
I would also like to show you something else that you can do with the element\_id: setting additional attributes for a ui-element.
In this case, we want to make the font-size of the label bigger and set it's style to underlined.
For this, we use the functions Label\_SetFontSize and Label\_SetStyle.

```  
  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")
  
  function Button_RunFunction(pressed_button_id)
    -- this function is run, when a button is pressed
    if pressed_button_id==button_ok_id then
      reaper.MB("OK Button is pressed", "OK Button", 0)
    elseif pressed_button_id==button_cancel_id then
      reaper.MB("Cancel Button is pressed", "Cancel Button", 0)
    end
  end

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)
    -- this function is run, when the checkstate of a checkbox is changed
    if checked_checkbox_id==checkbox_remember then
      reaper.MB("Checkbox \"Remember\" is "..tostring(checkstate), "Checkbox-State changed", 0)
    elseif checked_checkbox_id==checkbox_mysetting then
      reaper.MB("Checkbox \"my Setting\" is "..tostring(checkstate), "Checkbox-State changed", 0)
    end
  end

  function InputBox_RunFunction_Type(inputbox_id, entered_text)
    -- this function is run, when the user types in text into an inputbox
    reaper.ClearConsole()
    if inputbox_id==inputbox_name_of_setting then
      reaper.ShowConsoleMsg("NAME: "..entered_text)
    elseif inputbox_id==inputbox_description_of_setting then
      reaper.ShowConsoleMsg("DESCRIPTION: "..entered_text)
    end
  end

  function InputBox_RunFunction_Enter(inputbox_id, entered_text)
    -- this function is run, when the user hits enter into an inputbox
    if inputbox_id==inputbox_name_of_setting then
      reaper.MB(entered_text, "The typed text into NAME was", 0)
    elseif inputbox_id==inputbox_description_of_setting then
      reaper.MB(entered_text, "The typed text into DESCRIPTION was", 0)
    end
  end


  -- create new gui
  reagirl.Gui_New()

  -- add a textlabel to the top of the gui
  label_header=reagirl.Label_Add(30, 50, "This is a settings dialog", "Set the settings, as you wish", 0, false, nil)
  reagirl.Label_SetFontSize(label_header, 40) -- set the font-size of the label to 40
  reagirl.Label_SetStyle(label_header, 6, 0, 0) -- set the label to underlined

  -- add inputboxes to type in text
  inputbox_name_of_setting = reagirl.InputBox_Add(30, 105, 300, "Name of the setting:", 150, "Type in here the name of the setting", "No title", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)
  inputbox_description_of_setting = reagirl.InputBox_Add(30, 130, 300, "Description of the setting:", 150, "Type in here a description of the setting", "No Description", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)

  -- add two checkboxes to the gui
  checkbox_mysetting = reagirl.CheckBox_Add(30, 150, "My setting", "How shall my setting be set?", true, Checkbox_RunFunction)
  checkbox_remember = reagirl.CheckBox_Add(30, 170, "Remember chosen setting", "Shall this setting be used as future default?", true, Checkbox_RunFunction)

  -- add an ok-button and a cancel button to the gui
  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog", Button_RunFunction)
  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, "Cancel", "Discard changes and close dialog", Button_RunFunction)  

  -- open the new gui
  reagirl.Gui_Open("The dialog", "This is a demo dialog with some options.", 640, 250)

  function main()
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly
    reagirl.Gui_Manage()
    
    -- if the gui-window hasn't been closed, keep the script alive.
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
  end

  main()
```
Running this code will add the text "This is a settings dialog" to the gui in font-size 40 and underlined.

  
Example 6: the shape of the buttons is set to more round/edgier

  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")
  
  function Button_RunFunction(pressed_button_id)
    -- this function is run, when a button is pressed
    if pressed_button_id==button_ok_id then
      reaper.MB("OK Button is pressed", "OK Button", 0)
    elseif pressed_button_id==button_cancel_id then
      reaper.MB("Cancel Button is pressed", "Cancel Button", 0)
    end
  end

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)
    -- this function is run, when the checkstate of a checkbox is changed
    if checked_checkbox_id==checkbox_remember then
      reaper.MB("Checkbox \"Remember\" is "..tostring(checkstate), "Checkbox-State changed", 0)
    elseif checked_checkbox_id==checkbox_mysetting then
      reaper.MB("Checkbox \"my Setting\" is "..tostring(checkstate), "Checkbox-State changed", 0)
    end
  end

  function InputBox_RunFunction_Type(inputbox_id, entered_text)
    -- this function is run, when the user types in text into an inputbox
    reaper.ClearConsole()
    if inputbox_id==inputbox_name_of_setting then
      reaper.ShowConsoleMsg("NAME: "..entered_text)
    elseif inputbox_id==inputbox_description_of_setting then
      reaper.ShowConsoleMsg("DESCRIPTION: "..entered_text)
    end
  end

  function InputBox_RunFunction_Enter(inputbox_id, entered_text)
    -- this function is run, when the user hits enter into an inputbox
    if inputbox_id==inputbox_name_of_setting then
      reaper.MB(entered_text, "The typed text into NAME was", 0)
    elseif inputbox_id==inputbox_description_of_setting then
      reaper.MB(entered_text, "The typed text into DESCRIPTION was", 0)
    end
  end


  -- create new gui
  reagirl.Gui_New()

  -- add a textlabel to the top of the gui
  label_header=reagirl.Label_Add(30, 50, "This is a settings dialog", "Set the settings, as you wish", 0, false, nil)
  reagirl.Label_SetFontSize(label_header, 40) -- set the font-size of the label to 40
  reagirl.Label_SetStyle(label_header, 6, 0, 0) -- set the label to underlined

  -- add inputboxes to type in text
  inputbox_name_of_setting = reagirl.InputBox_Add(30, 105, 300, "Name of the setting:", 150, "Type in here the name of the setting", "No title", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)
  inputbox_description_of_setting = reagirl.InputBox_Add(30, 130, 300, "Description of the setting:", 150, "Type in here a description of the setting", "No Description", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)

  -- add two checkboxes to the gui
  checkbox_mysetting = reagirl.CheckBox_Add(30, 150, "My setting", "How shall my setting be set?", true, Checkbox_RunFunction)
  checkbox_remember = reagirl.CheckBox_Add(30, 170, "Remember chosen setting", "Shall this setting be used as future default?", true, Checkbox_RunFunction)

  -- add an ok-button and a cancel button to the gui
  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog", Button_RunFunction)
  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, "Cancel", "Discard changes and close dialog", Button_RunFunction)
  reagirl.Button_SetRadius(button_ok_id, 20)    -- make the ok-button round
  reagirl.Button_SetRadius(button_cancel_id, 0) -- make the cancel button square

  -- open the new gui
  reagirl.Gui_Open("The dialog", "This is a demo dialog with some options.", 640, 250)

  function main()
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly
    reagirl.Gui_Manage()
    
    -- if the gui-window hasn't been closed, keep the script alive.
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
  end

  main()
  
Example 7: let's make the background grey
  
  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")
  
  function Button_RunFunction(pressed_button_id)
    -- this function is run, when a button is pressed
    if pressed_button_id==button_ok_id then
      reaper.MB("OK Button is pressed", "OK Button", 0)
    elseif pressed_button_id==button_cancel_id then
      reaper.MB("Cancel Button is pressed", "Cancel Button", 0)
    end
  end

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)
    -- this function is run, when the checkstate of a checkbox is changed
    if checked_checkbox_id==checkbox_remember then
      reaper.MB("Checkbox \"Remember\" is "..tostring(checkstate), "Checkbox-State changed", 0)
    elseif checked_checkbox_id==checkbox_mysetting then
      reaper.MB("Checkbox \"my Setting\" is "..tostring(checkstate), "Checkbox-State changed", 0)
    end
  end

  function InputBox_RunFunction_Type(inputbox_id, entered_text)
    -- this function is run, when the user types in text into an inputbox
    reaper.ClearConsole()
    if inputbox_id==inputbox_name_of_setting then
      reaper.ShowConsoleMsg("NAME: "..entered_text)
    elseif inputbox_id==inputbox_description_of_setting then
      reaper.ShowConsoleMsg("DESCRIPTION: "..entered_text)
    end
  end

  function InputBox_RunFunction_Enter(inputbox_id, entered_text)
    -- this function is run, when the user hits enter into an inputbox
    if inputbox_id==inputbox_name_of_setting then
      reaper.MB(entered_text, "The typed text into NAME was", 0)
    elseif inputbox_id==inputbox_description_of_setting then
      reaper.MB(entered_text, "The typed text into DESCRIPTION was", 0)
    end
  end


  -- create new gui
  reagirl.Gui_New()

  -- add a textlabel to the top of the gui
  label_header=reagirl.Label_Add(30, 50, "This is a settings dialog", "Set the settings, as you wish", 0, false, nil)
  reagirl.Label_SetFontSize(label_header, 40) -- set the font-size of the label to 40
  reagirl.Label_SetStyle(label_header, 6, 0, 0) -- set the label to underlined

  -- add inputboxes to type in text
  inputbox_name_of_setting = reagirl.InputBox_Add(30, 105, 300, "Name of the setting:", 150, "Type in here the name of the setting", "No title", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)
  inputbox_description_of_setting = reagirl.InputBox_Add(30, 130, 300, "Description of the setting:", 150, "Type in here a description of the setting", "No Description", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)

  -- add two checkboxes to the gui
  checkbox_mysetting = reagirl.CheckBox_Add(30, 150, "My setting", "How shall my setting be set?", true, Checkbox_RunFunction)
  checkbox_remember = reagirl.CheckBox_Add(30, 170, "Remember chosen setting", "Shall this setting be used as future default?", true, Checkbox_RunFunction)

  -- add an ok-button and a cancel button to the gui
  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog", Button_RunFunction)
  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, "Cancel", "Discard changes and close dialog", Button_RunFunction)
  reagirl.Button_SetRadius(button_ok_id, 20)    -- make the ok-button round
  reagirl.Button_SetRadius(button_cancel_id, 0) -- make the cancel button square

  -- make the background grey
  reagirl.Background_GetSetColor(true, 55, 55, 55)

  -- open the new gui
  reagirl.Gui_Open("The dialog", "This is a demo dialog with some options.", 640, 250)

  function main()
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly
    reagirl.Gui_Manage()
    
    -- if the gui-window hasn't been closed, keep the script alive.
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
  end

  main()
  
  
Example 8: add an image to the gui of a bass guitar, which is anchored to the right side of the window
  
  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")
  
  function Button_RunFunction(pressed_button_id)
    -- this function is run, when a button is pressed
    if pressed_button_id==button_ok_id then
      reaper.MB("OK Button is pressed", "OK Button", 0)
    elseif pressed_button_id==button_cancel_id then
      reaper.MB("Cancel Button is pressed", "Cancel Button", 0)
    end
  end

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)
    -- this function is run, when the checkstate of a checkbox is changed
    if checked_checkbox_id==checkbox_remember then
      reaper.MB("Checkbox \"Remember\" is "..tostring(checkstate), "Checkbox-State changed", 0)
    elseif checked_checkbox_id==checkbox_mysetting then
      reaper.MB("Checkbox \"my Setting\" is "..tostring(checkstate), "Checkbox-State changed", 0)
    end
  end

  function InputBox_RunFunction_Type(inputbox_id, entered_text)
    -- this function is run, when the user types in text into an inputbox
    reaper.ClearConsole()
    if inputbox_id==inputbox_name_of_setting then
      reaper.ShowConsoleMsg("NAME: "..entered_text)
    elseif inputbox_id==inputbox_description_of_setting then
      reaper.ShowConsoleMsg("DESCRIPTION: "..entered_text)
    end
  end

  function InputBox_RunFunction_Enter(inputbox_id, entered_text)
    -- this function is run, when the user hits enter into an inputbox
    if inputbox_id==inputbox_name_of_setting then
      reaper.MB(entered_text, "The typed text into NAME was", 0)
    elseif inputbox_id==inputbox_description_of_setting then
      reaper.MB(entered_text, "The typed text into DESCRIPTION was", 0)
    end
  end


  -- create new gui
  reagirl.Gui_New()

  -- add an image of a bass guitar
  reagirl.Image_Add(reaper.GetResourcePath().."/Data/track_icons/bass.png", -150, 20, 100, 100, "A Bass guitar", "the graphics of a basss guitar", nil)

  -- add a textlabel to the top of the gui
  label_header=reagirl.Label_Add(30, 50, "This is a settings dialog", "Set the settings, as you wish", 0, false, nil)
  reagirl.Label_SetFontSize(label_header, 40) -- set the font-size of the label to 40
  reagirl.Label_SetStyle(label_header, 6, 0, 0) -- set the label to underlined

  -- add inputboxes to type in text
  inputbox_name_of_setting = reagirl.InputBox_Add(30, 105, 300, "Name of the setting:", 150, "Type in here the name of the setting", "No title", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)
  inputbox_description_of_setting = reagirl.InputBox_Add(30, 130, 300, "Description of the setting:", 150, "Type in here a description of the setting", "No Description", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)

  -- add two checkboxes to the gui
  checkbox_mysetting = reagirl.CheckBox_Add(30, 150, "My setting", "How shall my setting be set?", true, Checkbox_RunFunction)
  checkbox_remember = reagirl.CheckBox_Add(30, 170, "Remember chosen setting", "Shall this setting be used as future default?", true, Checkbox_RunFunction)

  -- add an ok-button and a cancel button to the gui
  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog", Button_RunFunction)
  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, "Cancel", "Discard changes and close dialog", Button_RunFunction)
  reagirl.Button_SetRadius(button_ok_id, 20)    -- make the ok-button round
  reagirl.Button_SetRadius(button_cancel_id, 0) -- make the cancel button square


  -- open the new gui
  reagirl.Gui_Open("The dialog", "This is a demo dialog with some options.", 640, 250)

  -- make the background grey
  reagirl.Background_GetSetColor(true, 55, 55, 55)

  function main()
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly
    reagirl.Gui_Manage()
    
    -- if the gui-window hasn't been closed, keep the script alive.
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
  end

  main()

Example 9: let's force minimum and maximum size of the window
  
  dofile(reaper.GetResourcePath().."/UserPlugins/reagirl.lua")
  
  function Button_RunFunction(pressed_button_id)
    -- this function is run, when a button is pressed
    if pressed_button_id==button_ok_id then
      reaper.MB("OK Button is pressed", "OK Button", 0)
    elseif pressed_button_id==button_cancel_id then
      reaper.MB("Cancel Button is pressed", "Cancel Button", 0)
    end
  end

  function Checkbox_RunFunction(checked_checkbox_id, checkstate)
    -- this function is run, when the checkstate of a checkbox is changed
    if checked_checkbox_id==checkbox_remember then
      reaper.MB("Checkbox \"Remember\" is "..tostring(checkstate), "Checkbox-State changed", 0)
    elseif checked_checkbox_id==checkbox_mysetting then
      reaper.MB("Checkbox \"my Setting\" is "..tostring(checkstate), "Checkbox-State changed", 0)
    end
  end

  function InputBox_RunFunction_Type(inputbox_id, entered_text)
    -- this function is run, when the user types in text into an inputbox
    reaper.ClearConsole()
    if inputbox_id==inputbox_name_of_setting then
      reaper.ShowConsoleMsg("NAME: "..entered_text)
    elseif inputbox_id==inputbox_description_of_setting then
      reaper.ShowConsoleMsg("DESCRIPTION: "..entered_text)
    end
  end

  function InputBox_RunFunction_Enter(inputbox_id, entered_text)
    -- this function is run, when the user hits enter into an inputbox
    if inputbox_id==inputbox_name_of_setting then
      reaper.MB(entered_text, "The typed text into NAME was", 0)
    elseif inputbox_id==inputbox_description_of_setting then
      reaper.MB(entered_text, "The typed text into DESCRIPTION was", 0)
    end
  end


  -- create new gui
  reagirl.Gui_New()

  -- add an image of a bass guitar
  reagirl.Image_Add(reaper.GetResourcePath().."/Data/track_icons/bass.png", -150, 20, 100, 100, "A Bass guitar", "the graphics of a basss guitar", nil)

  -- add a textlabel to the top of the gui
  label_header=reagirl.Label_Add(30, 50, "This is a settings dialog", "Set the settings, as you wish", 0, false, nil)
  reagirl.Label_SetFontSize(label_header, 40) -- set the font-size of the label to 40
  reagirl.Label_SetStyle(label_header, 6, 0, 0) -- set the label to underlined

  -- add inputboxes to type in text
  inputbox_name_of_setting = reagirl.InputBox_Add(30, 105, 300, "Name of the setting:", 150, "Type in here the name of the setting", "No title", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)
  inputbox_description_of_setting = reagirl.InputBox_Add(30, 130, 300, "Description of the setting:", 150, "Type in here a description of the setting", "No Description", InputBox_RunFunction_Enter, InputBox_RunFunction_Type)

  -- add two checkboxes to the gui
  checkbox_mysetting = reagirl.CheckBox_Add(30, 150, "My setting", "How shall my setting be set?", true, Checkbox_RunFunction)
  checkbox_remember = reagirl.CheckBox_Add(30, 170, "Remember chosen setting", "Shall this setting be used as future default?", true, Checkbox_RunFunction)

  -- add an ok-button and a cancel button to the gui
  button_ok_id = reagirl.Button_Add(30, 200, 0, 0, "OK", "Apply changes and close dialog", Button_RunFunction)
  button_cancel_id = reagirl.Button_Add(70, 200, 0, 0, "Cancel", "Discard changes and close dialog", Button_RunFunction)
  reagirl.Button_SetRadius(button_ok_id, 20)    -- make the ok-button round
  reagirl.Button_SetRadius(button_cancel_id, 0) -- make the cancel button square

  -- let's force window-sizes
  reagirl.Window_ForceSize_Minimum(550, 200)  -- set the minimum size of the window
  reagirl.Window_ForceSize_Maximum(1150, 400) -- set the maximum size of the window

  -- open the new gui
  reagirl.Gui_Open("The dialog", "This is a demo dialog with some options.", 640, 250)

  -- make the background grey
  reagirl.Background_GetSetColor(true, 55, 55, 55)

  function main()
    -- a function that runs the gui-manage function in the background, so the gui is updated correctly
    reagirl.Gui_Manage()
    
    -- if the gui-window hasn't been closed, keep the script alive.
    if reagirl.Gui_IsOpen()==true then reaper.defer(main) end
  end

  main()